<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>STS — Seasonal Time System</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest">
  <meta name="theme-color" content="#0b0e12">

  <style>
    :root{--bg:#0b0e12;--fg:#e9eef5;--muted:#a9b4c2;--accent:#7cc7ff;--card:#131821;--warn:#ffcc66;--danger:#ff6b6b}
    *,*::before,*::after{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow-x:hidden}
    img,svg,video{max-width:100%;height:auto;display:block}

    .wrap{max-width:980px;margin:0 auto;padding:20px}

    /* Header row: centered brand left, current clock right (desktop); stacked on mobile */
    .header{display:flex;gap:16px;align-items:flex-start;justify-content:space-between}
    .header-title{flex:1; text-align:center}
    .brand-1{font-size:clamp(2.6rem, 12vw, 5rem); line-height:1; margin:0}
    .brand-2{font-size:clamp(1.2rem, 4vw, 2.2rem); line-height:1.15; margin:4px 0 6px}
    .brand-3{color:var(--muted); font-size:clamp(1.0rem, 3.2vw, 1.2rem); margin:0}

    .grid{display:grid;gap:16px;grid-template-columns:1fr}
    @media (min-width:980px){ .grid{grid-template-columns:1fr 1fr} }

    .card{background:var(--card);border:1px solid #1f2633;border-radius:14px;padding:16px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .muted{color:var(--muted)}
    .small{font-size:0.92rem;color:var(--muted)}
    .tiny{font-size:0.85rem;color:var(--muted)}
    .sep{height:1px;background:#1f2633;margin:10px 0}

    .card-title{font-weight:700; font-size:clamp(1.05rem,2.2vw,1.35rem)}
    .section-title{font-weight:700; font-size:clamp(1.05rem,2.2vw,1.35rem)}

    label{display:block;font-size:0.9rem;margin:10px 0 4px}
    input,select,button{background:#0f1420;color:var(--fg);border:1px solid #243048;border-radius:10px;padding:10px 12px;font:inherit}
    button{cursor:pointer}

    /* Clocks */
    #liveSTS{font-size:clamp(2.6rem, 12vw, 5rem); line-height:1; letter-spacing:0.5px}
    #manSTS,#revLocal,#qOut{font-size:clamp(1.8rem, 7vw, 2.4rem); line-height:1.1}

    .cols2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .cols3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}

    /* Mobile polish */
    @media (max-width:980px){
      .header{flex-direction:column;align-items:stretch}
    }
    @media (max-width:520px){
      .wrap{padding:14px}
      .card{padding:12px}
      .grid{gap:12px}
      .row{gap:8px}
      .cols2,.cols3{grid-template-columns:1fr}
      input,select,button{width:100%;min-height:44px;font-size:16px}
      #btnAbout{width:100%}
    }

    .error{color:var(--danger)}
    .badge{display:inline-block; padding:2px 8px; border-radius:999px; background:#203049; color:#cfe8ff; font-size:0.75rem; margin-left:6px}
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Header row: brand + CURRENT STS TIME -->
    <div class="header">
      <div class="header-title">
        <h1 class="brand-1">STS</h1>
        <h2 class="brand-2">Seasonal Time System</h2>
        <p class="brand-3">Aligning time with natural rhythms</p>
      </div>

      <!-- CURRENT STS TIME -->
      <div class="card" style="flex:0 1 460px;">
        <div class="row" style="justify-content:space-between;">
          <div class="card-title">Current STS time</div>
          <div class="row">
            <span class="muted">Hemisphere</span>
            <select id="hemiAuto">
              <option value="north" selected>North</option>
              <option value="south">South</option>
            </select>
          </div>
        </div>

        <div id="liveSTS">--:--</div>
        <div class="row" style="justify-content:space-between; gap:12px; margin-top:8px;">
          <div class="small" id="liveLine1">Local time | UTC 0</div>
          <label class="tiny" style="display:flex;align-items:center;gap:6px">
            <input id="keepAwake" type="checkbox" style="width:auto;height:auto"> Keep screen on
          </label>
        </div>
        <div id="liveLine2" class="tiny">Day hour length: — min | Night hour length: — min | minute-of-year: —</div>
        <div id="liveDST" class="tiny">DST: —</div>
        <div id="autoErr" class="tiny error"></div>
      </div>
    </div>

    <!-- QUICK CONVERTER (unified) -->
    <div class="card" style="margin-top:16px">
      <div class="row" style="justify-content:space-between;">
        <div class="card-title">Quick converter</div>
        <div class="row">
          <span class="muted">Mode</span>
          <select id="qMode">
            <option value="c2s" selected>Civil → STS</option>
            <option value="s2c">STS → Civil</option>
          </select>
          <span class="muted">Hemisphere</span>
          <select id="hemiQuick">
            <option value="north" selected>North</option>
            <option value="south">South</option>
          </select>
        </div>
      </div>

      <div class="cols2">
        <div>
          <label for="qDateU">Date</label>
          <input id="qDateU" type="date">

          <label for="qTimeU" id="qTimeLabel">Time</label>
          <input id="qTimeU" type="time" step="60" placeholder="hh:mm">

          <div class="row" style="justify-content:space-between; margin-top:10px">
            <button id="qBtnRun">Convert</button>
            <span id="qInfo" class="tiny muted"></span>
          </div>

          <div id="qOut" style="margin-top:8px">—</div>
          <div id="qDet" class="tiny">UTC 0: — | Day/Night: — / — | minute-of-year: — | DST: —</div>
          <div id="qGuidance" class="tiny muted" style="margin-top:6px"></div>
          <div id="qErr" class="tiny error"></div>
        </div>
      </div>
    </div>

    <div class="grid" style="margin-top:16px">
      <!-- MANUAL (Advanced) -->
      <div class="card">
        <div class="row" style="justify-content:space-between; align-items:baseline;">
          <div class="card-title">Manual (Advanced)</div>
          <span class="tiny muted">Manual panel does not affect the live clock.</span>
        </div>

        <!-- Civil -> STS (Advanced) -->
        <div class="sep"></div>
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div class="section-title">Civil → STS</div>
          <div class="row">
            <span class="muted">Hemisphere</span>
            <select id="hemiManA">
              <option value="north" selected>North</option>
              <option value="south">South</option>
            </select>
          </div>
          <div class="row">
            <span class="muted">Zone input</span>
            <select id="zoneModeA">
              <option value="iana" selected>IANA</option>
              <option value="offset">UTC offset</option>
            </select>
          </div>
        </div>

        <div class="cols3">
          <div>
            <label for="dateIn">Date</label>
            <input id="dateIn" type="date" />
          </div>
          <div>
            <label for="timeIn">Time</label>
            <input id="timeIn" type="time" step="60" />
          </div>

          <!-- IANA -->
          <div id="ianaBoxA">
            <label for="tzIn">Time zone (IANA)</label>
            <input id="tzIn" type="text" placeholder="e.g., Europe/Rome" />
            <label for="dstIn">Daylight Saving Time</label>
            <select id="dstIn">
              <option value="auto" selected>Auto</option>
              <option value="on">On</option>
              <option value="off">Off</option>
            </select>
          </div>

          <!-- Offset -->
          <div id="offsetBoxA" style="display:none">
            <label for="offsetIn">UTC offset</label>
            <input id="offsetIn" type="text" placeholder="e.g., UTC+2, +5:30, -3" />
            <label class="tiny" style="display:flex;align-items:center;gap:6px;margin-top:8px">
              <input id="offsetDSTMapA" type="checkbox" style="width:auto;height:auto">
              DST (apply −60′ to mapping)
            </label>
          </div>
        </div>

        <div class="row" style="justify-content:space-between;margin-top:10px">
          <button id="btnCalcA">Compute STS</button>
          <span class="tiny muted"></span>
        </div>
        <div id="manSTS" style="margin-top:8px">STS: --:--</div>
        <div id="manLine1" class="small">Local | UTC 0</div>
        <div id="manLine2" class="tiny">Day/Night: — / — | minute-of-year: —</div>
        <div id="manErr" class="tiny error"></div>

        <!-- STS -> Civil (Advanced) -->
        <div class="sep" style="margin-top:14px"></div>
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div class="section-title">STS → Civil</div>
          <div class="row">
            <span class="muted">Hemisphere</span>
            <select id="hemiManB">
              <option value="north" selected>North</option>
              <option value="south">South</option>
            </select>
          </div>
          <div class="row">
            <span class="muted">Zone input</span>
            <select id="zoneModeB">
              <option value="iana" selected>IANA</option>
              <option value="offset">UTC offset</option>
            </select>
          </div>
        </div>

        <div class="cols3">
          <div>
            <label for="dateRev">Date</label>
            <input id="dateRev" type="date" />
          </div>
          <div>
            <label for="timeRevSTS">STS time</label>
            <input id="timeRevSTS" type="time" step="60" />
          </div>

          <!-- IANA -->
          <div id="ianaBoxB">
            <label for="tzRev">Time zone (IANA)</label>
            <input id="tzRev" type="text" placeholder="e.g., Europe/Rome" />
            <label for="dstRev">Daylight Saving Time</label>
            <select id="dstRev">
              <option value="auto" selected>Auto</option>
              <option value="on">On</option>
              <option value="off">Off</option>
            </select>
          </div>

          <!-- Offset -->
          <div id="offsetBoxB" style="display:none">
            <label for="offsetRev">UTC offset</label>
            <input id="offsetRev" type="text" placeholder="e.g., UTC+2, +5:30, -3" />
            <label class="tiny" style="display:flex;align-items:center;gap:6px;margin-top:8px">
              <input id="offsetDSTMapB" type="checkbox" style="width:auto;height:auto">
              DST (apply −60′ to mapping)
            </label>
          </div>
        </div>

        <div class="row" style="justify-content:space-between;margin-top:10px">
          <button id="btnCalcB">Convert to Local</button>
          <span class="tiny muted">Output can be next day when DST is active.</span>
        </div>
        <div id="revLocal" style="margin-top:8px">Local: --:--</div>
        <div id="revLine1" class="small">Local date/time | UTC 0</div>
        <div id="revLine2" class="tiny">Day/Night: — / — | minute-of-year: —</div>
        <div id="revErr" class="tiny error"></div>
      </div>

      <!-- About/Credits -->
      <div class="card">
        <div class="row" style="justify-content:center; margin: 8px 0 0;">
          <button id="btnAbout">About/Credits</button>
        </div>
        <div id="aboutCard" class="card" style="display:none; margin-top:12px;">
          <div id="aboutContent" class="tiny" style="line-height:1.55; white-space:pre-wrap">
            Loading…
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ---------- Formatting ----------
  const pad2 = n => n.toString().padStart(2,'0');
  const fmtHM = (h,m) => `${pad2(h)}:${pad2(m)}`;
  const fmtIsoUTC0 = d => `${d.getUTCFullYear()}-${pad2(d.getUTCMonth()+1)}-${pad2(d.getUTCDate())} ${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())}`;
  const fmtIsoLocal = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;

  // ---------- Load eqsol.json ----------
  let EQSOL_DB = null;
  async function loadEqSolDB(){
    const res = await fetch('./eqsol.json', {cache:'no-cache'});
    if(!res.ok) throw new Error(`Cannot load eqsol.json (HTTP ${res.status})`);
    EQSOL_DB = await res.json();
  }

  // ---------- TZ & DST via IANA ----------
  function resolvedLocalZone(){
    try{ return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC'; }
    catch{ return 'UTC'; }
  }
  function offsetMinutesForZone(dateUTC, tz){
    let val = '';
    const base = { timeZone: tz, timeZoneName: 'longOffset', hour12:false, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit' };
    const short= { ...base, timeZoneName:'shortOffset' };
    try{ val = new Intl.DateTimeFormat('en-US', base).formatToParts(dateUTC).find(p=>p.type==='timeZoneName')?.value || '';}catch{}
    if(!val){ try{ val = new Intl.DateTimeFormat('en-US', short).formatToParts(dateUTC).find(p=>p.type==='timeZoneName')?.value || '';}catch{} }
    const m = val.match(/([+-])(\d{1,2})(?::?(\d{2}))?/);
    if(!m) return 0;
    const sign = m[1]==='-' ? -1 : 1;
    const hh = parseInt(m[2],10);
    const mm = m[3] ? parseInt(m[3],10) : 0;
    return sign*(hh*60 + mm);
  }
  function isLeapYear(y){ return (y%4===0 && y%100!==0) || (y%400===0); }
  function standardOffsetForYear(tz, year){
    const jan = new Date(Date.UTC(year,0,1,12,0,0));
    const jul = new Date(Date.UTC(year,6,1,12,0,0));
    const offJan = offsetMinutesForZone(jan, tz);
    const offJul = offsetMinutesForZone(jul, tz);
    return Math.min(offJan, offJul);
  }
  function isDSTActiveAtUTCInstant(tz, msUTC){
    const d = new Date(msUTC);
    const year = d.getUTCFullYear();
    const offNow = offsetMinutesForZone(d, tz);
    const std = standardOffsetForYear(tz, year);
    return offNow > std;
  }
  function isDSTActiveYMDHM(tz, y, M, d, h, m){
    const instantUTC = Date.UTC(y, M-1, d, h, m, 0);
    return isDSTActiveAtUTCInstant(tz, instantUTC);
  }

  // ---------- UTC offset parsing ----------
  function parseUTCOffsetToMinutes(str){
    if (!str) throw new Error('Please enter a UTC offset.');
    let s = str.trim().toUpperCase().replace(/^GMT|^UTC/,'').trim();
    if (s === 'Z' || s === '') return 0;
    const m = s.match(/^([+-])?(\d{1,2})(?::?(\d{2}))?$/);
    if (!m) throw new Error('Invalid UTC offset. Examples: UTC+2, +5:30, -3');
    const sign = (m[1] === '-') ? -1 : 1;
    const hh = parseInt(m[2],10);
    const mm = m[3] ? parseInt(m[3],10) : 0;
    if (hh > 14 || mm >= 60) throw new Error('Offset out of range.');
    return sign*(hh*60 + mm);
  }

  // ---------- Anchors & minute-of-year (UTC0) ----------
  function toMinuteOfYearUTC0(isoUTC){
    const d = new Date(isoUTC);
    const start = Date.UTC(d.getUTCFullYear(),0,1,0,0,0);
    return Math.floor((d.getTime() - start)/60000);
  }
  function anchorsForYear(year){
    if(!EQSOL_DB || !EQSOL_DB.data || !EQSOL_DB.data[year]) return null;
    const row = EQSOL_DB.data[year];
    const a = toMinuteOfYearUTC0(row.eq1);
    const b = toMinuteOfYearUTC0(row.sol1);
    const c = toMinuteOfYearUTC0(row.eq2);
    const d = toMinuteOfYearUTC0(row.sol2);
    return {a,b,c,d, minutesInYear: (isLeapYear(year)?366:365)*1440};
  }
  function minuteOfYearUTC0FromEpoch(msUTC){
    const d = new Date(msUTC);
    const start = Date.UTC(d.getUTCFullYear(),0,1,0,0,0);
    const P = (isLeapYear(d.getUTCFullYear())?366:365)*1440;
    let k = Math.floor((msUTC - start)/60000);
    if (k < 0) k = 0;
    if (k >= P) k = P-1;
    return {moy:k, year:d.getUTCFullYear(), minutesInYear:P};
  }

  // ---------- Seasonal curve (C¹) ----------
  function hermite(y0, y1, m0, m1, t, L){
    const t2 = t*t, t3 = t2*t;
    const h00 =  2*t3 - 3*t2 + 1;
    const h10 =    t3 - 2*t2 + t;
    const h01 = -2*t3 + 3*t2;
    const h11 =    t3 -   t2;
    return h00*y0 + h10*m0*L + h01*y1 + h11*m1*L;
  }
  function seasonalScalarC1(m, anchors){
    const {a,b,c,d,minutesInYear:P} = anchors;
    const mA =  2 / ( (b - (d - P)) );
    const mB =  0;
    const mC = (-1 - 0) / (d - a);
    const mD =  0;
    if (m >= a && m < b){ const L=(b-a), t=(m-a)/L; return hermite(0,+1,mA,mB,t,L); }
    if (m >= b && m < c){ const L=(c-b), t=(m-b)/L; return hermite(+1,0,mB,mC,t,L); }
    if (m >= c && m < d){ const L=(d-c), t=(m-c)/L; return hermite(0,-1,mC,mD,t,L); }
    const aP = a + P; const L=(aP - d), t=(m >= d ? (m-d)/L : (m+P-d)/L);
    return hermite(-1,0,mD,mA,t,L);
  }

  // ---------- Day/Night lengths ----------
  const AMP = 10; // ±10 minutes
  function hourLengthsForMinute(m, anchors, hemisphere){
    let s = seasonalScalarC1(m, anchors);
    if (hemisphere === 'south') s = -s;
    return { dayLen: 60 + AMP*s, nightLen: 60 - AMP*s, s };
  }

  // ---------- Civil → STS (mapping) ----------
  function minutesToSTS(wallMinutes, dayLen, nightLen){
    const Kd = 60 / dayLen;
    const Kn = 60 / nightLen;
    const M1 = 6 * nightLen;
    const M2 = 12 * dayLen;
    const M12 = M1 + M2;

    let stsMin;
    if (wallMinutes < M1){
      stsMin = wallMinutes * Kn;
    } else if (wallMinutes < M12){
      stsMin = 360 + (wallMinutes - M1) * Kd;
    } else {
      stsMin = 1080 + (wallMinutes - M12) * Kn;
    }
    let hh = Math.floor(stsMin / 60) % 24;
    let mm = Math.round(stsMin % 60);
    if (mm === 60){ mm = 0; hh = (hh + 1) % 24; }
    return { hh, mm, stsMin };
  }

  // ---------- STS → Civil (inverse mapping) ----------
  function stsToWallMinutes(stsMin, dayLen, nightLen){
    if (stsMin < 360){
      return stsMin * (nightLen/60);
    } else if (stsMin < 1080){
      return 6*nightLen + (stsMin - 360) * (dayLen/60);
    } else {
      return 6*nightLen + 12*dayLen + (stsMin - 1080) * (nightLen/60);
    }
  }

  // ---------- Wall-clock → UTC ms ----------
  function wallClockToUTCms_IANA(y,M,d,h,m,tz,dstMode){
    const stdOff = standardOffsetForYear(tz, y);
    let dstActive = false;
    if (dstMode === 'on') dstActive = true;
    else if (dstMode === 'off') dstActive = false;
    else dstActive = isDSTActiveYMDHM(tz, y, M, d, h, m);

    let wallMinutes = h*60 + m - (dstActive ? 60 : 0);
    let dateUTC = Date.UTC(y, M-1, d, 0, 0, 0);
    while (wallMinutes < 0){ wallMinutes += 1440; dateUTC -= 86400000; }
    while (wallMinutes >= 1440){ wallMinutes -= 1440; dateUTC += 86400000; }

    const msUTC = dateUTC + wallMinutes*60000 - stdOff*60000;
    return { msUTC, wallMinutes_std: wallMinutes, stdOff, dstActive };
  }
  function wallClockToUTCms_Offset(y,M,d,h,m,offsetMinutes, applyDSTMap){
    let wallMinutes = h*60 + m - (applyDSTMap ? 60 : 0);
    let dateUTC = Date.UTC(y, M-1, d, 0, 0, 0);
    while (wallMinutes < 0){ wallMinutes += 1440; dateUTC -= 86400000; }
    while (wallMinutes >= 1440){ wallMinutes -= 1440; dateUTC += 86400000; }
    const msUTC = dateUTC + wallMinutes*60000 - offsetMinutes*60000;
    return { msUTC, wallMinutes_std: wallMinutes, stdOff: offsetMinutes, dstActive: !!applyDSTMap };
  }

  // ---------- Automatic live ----------
  function hourLenFmt(x){ return `${x.toFixed(2)} min`; }

  function autoUpdate(){
    const now = new Date();
    const tz = resolvedLocalZone();
    const hemi = document.getElementById('hemiAuto').value;

    try{
      const y = now.getFullYear(), M = now.getMonth()+1, d = now.getDate(), h = now.getHours(), mi = now.getMinutes();
      const { msUTC, wallMinutes_std } = wallClockToUTCms_IANA(y, M, d, h, mi, tz, 'auto');

      const { moy, year } = minuteOfYearUTC0FromEpoch(msUTC);
      const anc = anchorsForYear(year);
      if (!anc) throw new Error(`Anchors not found for year ${year} in eqsol.json.`);

      const { dayLen, nightLen } = hourLengthsForMinute(moy, anc, hemi);
      const { hh, mm } = minutesToSTS(wallMinutes_std, dayLen, nightLen);

      document.getElementById('liveSTS').textContent = fmtHM(hh, mm);

      const offNow = offsetMinutesForZone(new Date(msUTC), tz);
      const dstNow = isDSTActiveAtUTCInstant(tz, msUTC);
      const sign = offNow>=0?'+':'';
      const offTxt = `UTC${sign}${Math.trunc(offNow/60)}:${pad2(Math.abs(offNow%60))}`;
      const localLabel = `${fmtIsoLocal(now)} (${offTxt}, ${tz})`;
      const utcLabel   = `${fmtIsoUTC0(new Date(msUTC))} (UTC 0)`;
      document.getElementById('liveLine1').textContent = `${localLabel} | ${utcLabel}`;
      document.getElementById('liveLine2').textContent =
        `Day hour length: ${hourLenFmt(dayLen)} | Night hour length: ${hourLenFmt(nightLen)} | minute-of-year: ${moy}`;
      document.getElementById('liveDST').textContent = `DST: ${dstNow ? 'On' : 'Off'}`;

      document.getElementById('autoErr').textContent = '';
    }catch(err){
      document.getElementById('autoErr').textContent = err.message || String(err);
    }
  }

  // ---------- Quick converter (unified) ----------
  function quickSetModeUI(){
    const mode = document.getElementById('qMode').value;
    const tz = resolvedLocalZone();
    const dateStr = document.getElementById('qDateU').value || '';
    const timeStr = document.getElementById('qTimeU').value || '';
    document.getElementById('qOut').textContent = '—';
    document.getElementById('qDet').textContent = 'UTC 0: — | Day/Night: — / — | minute-of-year: — | DST: —';
    document.getElementById('qErr').textContent = '';
    document.getElementById('qInfo').textContent = (dateStr&&timeStr)? `${fmtIsoLocal(new Date(dateStr+'T'+timeStr))} (${tz})` : '';
    document.getElementById('qGuidance').textContent = (mode==='s2c') ? 'Output can be next day when DST is active.' : '';
    document.getElementById('qTimeLabel').textContent = (mode==='s2c') ? 'STS time' : 'Time';
    document.getElementById('qTimeU').placeholder = (mode==='s2c') ? 'hh:mm (STS)' : 'hh:mm';
  }

  function quickRun(){
    const mode = document.getElementById('qMode').value;
    if (mode === 's2c') return quickS2C_unified();
    return quickC2S_unified();
  }

  function quickC2S_unified(){
    const dateStr = document.getElementById('qDateU').value;
    const timeStr = document.getElementById('qTimeU').value;
    const hemi = document.getElementById('hemiQuick').value;
    const err = document.getElementById('qErr'); err.textContent = '';

    try{
      if (!dateStr || !timeStr) throw new Error('Enter date and time.');
      const [Y,M,D] = dateStr.split('-').map(Number);
      const [h,m]   = timeStr.split(':').map(Number);
      const tz = resolvedLocalZone();

      const { msUTC, wallMinutes_std } = wallClockToUTCms_IANA(Y,M,D,h,m,tz,'auto');
      const { moy, year } = minuteOfYearUTC0FromEpoch(msUTC);
      const anc = anchorsForYear(year);
      const { dayLen, nightLen } = hourLengthsForMinute(moy, anc, hemi);
      const { hh, mm, stsMin } = minutesToSTS(wallMinutes_std, dayLen, nightLen);
      const dstNow = isDSTActiveAtUTCInstant(tz, msUTC);

      document.getElementById('qOut').textContent = `STS: ${fmtHM(hh,mm)}`;
      document.getElementById('qDet').textContent =
        `UTC 0: ${fmtIsoUTC0(new Date(msUTC))} | Day/Night: ${dayLen.toFixed(2)} / ${nightLen.toFixed(2)} | minute-of-year: ${moy} | DST: ${dstNow?'On':'Off'}`;
      document.getElementById('qInfo').textContent = `${fmtIsoLocal(new Date(Y, M-1, D, h, m))} (${tz})`;

      dbgSet({context:'Quick C→S', tz, wallMinutes_std, msUTC:new Date(msUTC).toISOString(), moy, dayLen, nightLen, stsMin, hemi, dstNow});
    }catch(e){ err.textContent = e.message || String(e); }
  }

  function iterateDayLengthsForDate(y,M,d, tzOrOffset, isIANA, hemi, stsMin){
    // initial guess: local noon (standard) → UTC
    const stdOff = isIANA ? standardOffsetForYear(tzOrOffset, y) : tzOrOffset;
    const dateUTC = Date.UTC(y, M-1, d, 0, 0, 0);
    let msUTC = dateUTC + 12*60*60000 - stdOff*60000;

    let lastW = null, wm = null, moy = null, year=null, anc=null, dayLen=null, nightLen=null;
    for (let i=0;i<2;i++){
      ({ moy, year } = minuteOfYearUTC0FromEpoch(msUTC));
      anc = anchorsForYear(year);
      ({ dayLen, nightLen } = hourLengthsForMinute(moy, anc, hemi));
      wm = stsToWallMinutes(stsMin, dayLen, nightLen); // standard wall minutes
      msUTC = dateUTC + wm*60000 - stdOff*60000;
      if (lastW !== null && Math.abs(wm-lastW) < 0.5) break;
      lastW = wm;
    }
    return { wm, msUTC, moy, year, dayLen, nightLen, stdOff };
  }

  function quickS2C_unified(){
    const dateStr = document.getElementById('qDateU').value;
    const timeSTS = document.getElementById('qTimeU').value;
    const hemi = document.getElementById('hemiQuick').value;
    const err = document.getElementById('qErr'); err.textContent = '';
    try{
      if (!dateStr || !timeSTS) throw new Error('Enter date and STS time.');
      const [Y,M,D] = dateStr.split('-').map(Number);
      const [hs,ms] = timeSTS.split(':').map(Number);
      const stsMin = hs*60 + ms;
      const tz = resolvedLocalZone();

      const { wm, msUTC, moy, year, dayLen, nightLen } =
        iterateDayLengthsForDate(Y,M,D, tz, true, hemi, stsMin);

      const dstActive = isDSTActiveAtUTCInstant(tz, msUTC);
      let localMin = wm + (dstActive ? 60 : 0);
      let dayShift = 0;
      if (localMin >= 1440){ localMin -= 1440; dayShift = +1; }
      if (localMin < 0){ localMin += 1440; dayShift = -1; }

      const hh = Math.floor(localMin/60), mm = Math.round(localMin%60) % 60;
      const badge = dayShift!==0 ? ` <span class="badge">${dayShift>0?'next day':'prev day'}${dstActive?' · DST':''}</span>` : '';
      document.getElementById('qOut').innerHTML = `Local: ${fmtHM(hh,mm)}${badge}`;

      document.getElementById('qDet').textContent =
        `UTC 0: ${fmtIsoUTC0(new Date(msUTC))} | Day/Night: ${dayLen.toFixed(2)} / ${nightLen.toFixed(2)} | minute-of-year: ${moy} | DST: ${dstActive?'On':'Off'}`;
      document.getElementById('qInfo').textContent = `${Y}-${pad2(M)}-${pad2(D)} STS ${fmtHM(hs,ms)} (${tz})`;

      dbgSet({context:'Quick S→C', tz, dstActive, wm, localMin, msUTC:new Date(msUTC).toISOString(), moy, dayLen, nightLen, hemi, stsMin, dayShift});
    }catch(e){ err.textContent = e.message || String(e); }
  }

  // ---------- Manual (Advanced) Civil → STS ----------
  function manualC2S(){
    const hemi = document.getElementById('hemiManA').value;
    const mode = document.getElementById('zoneModeA').value;
    const dateStr = document.getElementById('dateIn').value;
    const timeStr = document.getElementById('timeIn').value;
    const err = document.getElementById('manErr'); err.textContent = '';

    try{
      if (!dateStr || !timeStr) throw new Error('Please enter date and time.');
      const [Y,M,D] = dateStr.split('-').map(Number);
      const [h,m]   = timeStr.split(':').map(Number);

      let msUTC, wallMinutes_std, stdOff, dstActive, tzLabel, offNow;
      if (mode === 'iana'){
        const tz = (document.getElementById('tzIn').value||'').trim();
        const dstMode = document.getElementById('dstIn').value;
        if(!tz) throw new Error('Enter a valid IANA zone (e.g., Europe/Rome).');
        void new Intl.DateTimeFormat('en-US', { timeZone: tz }).format();
        ({ msUTC, wallMinutes_std, stdOff, dstActive } = wallClockToUTCms_IANA(Y,M,D,h,m,tz,dstMode));
        offNow = offsetMinutesForZone(new Date(msUTC), tz);
        tzLabel = `${tz}`;
      } else {
        const offStr = (document.getElementById('offsetIn').value||'').trim();
        const applyDST = document.getElementById('offsetDSTMapA').checked;
        const offMin = parseUTCOffsetToMinutes(offStr);
        ({ msUTC, wallMinutes_std, stdOff, dstActive } = wallClockToUTCms_Offset(Y,M,D,h,m,offMin, applyDST));
        offNow = offMin + (applyDST ? 60 : 0);
        tzLabel = `UTC${offMin>=0?'+':''}${Math.trunc(offMin/60)}:${pad2(Math.abs(offMin%60))}`;
      }

      const { moy, year } = minuteOfYearUTC0FromEpoch(msUTC);
      const anc = anchorsForYear(year);
      const { dayLen, nightLen } = hourLengthsForMinute(moy, anc, hemi);
      const { hh, mm, stsMin } = minutesToSTS(wallMinutes_std, dayLen, nightLen);

      document.getElementById('manSTS').textContent = `STS: ${fmtHM(hh,mm)}`;
      const utcLabel = `${fmtIsoUTC0(new Date(msUTC))} (UTC 0)`;
      const localLabel = `${Y}-${pad2(M)}-${pad2(D)} ${pad2(h)}:${pad2(m)} (${tzLabel})`;
      document.getElementById('manLine1').textContent = `${localLabel} | ${utcLabel}`;
      document.getElementById('manLine2').textContent =
        `Day/Night: ${dayLen.toFixed(2)} / ${nightLen.toFixed(2)} | minute-of-year: ${moy}`;

      dbgSet({context:'Manual C→S', mode, tzLabel, stdOff, dstActive, wallMinutes_std, msUTC:new Date(msUTC).toISOString(), moy, dayLen, nightLen, stsMin, hemi, offNow});
    }catch(e){
      err.textContent = e.message || String(e);
      document.getElementById('manSTS').textContent = 'STS: --:--';
      document.getElementById('manLine1').textContent = 'Local | UTC 0';
      document.getElementById('manLine2').textContent = 'Day/Night: — / — | minute-of-year: —';
    }
  }

  // ---------- Manual (Advanced) STS → Civil ----------
  function manualS2C(){
    const hemi = document.getElementById('hemiManB').value;
    const mode = document.getElementById('zoneModeB').value;
    const dateStr = document.getElementById('dateRev').value;
    const timeSTS = document.getElementById('timeRevSTS').value;
    const err = document.getElementById('revErr'); err.textContent='';

    try{
      if (!dateStr || !timeSTS) throw new Error('Please enter date and STS time.');
      const [Y,M,D] = dateStr.split('-').map(Number);
      const [hs,ms] = timeSTS.split(':').map(Number);
      const stsMin = hs*60 + ms;

      let wm, msUTC, moy, year, dayLen, nightLen, tzLabel, dstActiveDisp=false;
      if (mode === 'iana'){
        const tz = (document.getElementById('tzRev').value||'').trim();
        const dstMode = document.getElementById('dstRev').value;
        if(!tz) throw new Error('Enter a valid IANA zone (e.g., Europe/Rome).');
        void new Intl.DateTimeFormat('en-US', { timeZone: tz }).format();

        ({ wm, msUTC, moy, year, dayLen, nightLen } =
          iterateDayLengthsForDate(Y,M,D, tz, true, hemi, stsMin));

        if (dstMode === 'on') dstActiveDisp = true;
        else if (dstMode === 'off') dstActiveDisp = false;
        else dstActiveDisp = isDSTActiveAtUTCInstant(tz, msUTC);
        tzLabel = `${tz}`;
      } else {
        const offStr = (document.getElementById('offsetRev').value||'').trim();
        const applyDST = document.getElementById('offsetDSTMapB').checked;
        const offMin = parseUTCOffsetToMinutes(offStr);

        ({ wm, msUTC, moy, year, dayLen, nightLen } =
          iterateDayLengthsForDate(Y,M,D, offMin, false, hemi, stsMin));

        dstActiveDisp = !!applyDST;
        tzLabel = `UTC${offMin>=0?'+':''}${Math.trunc(offMin/60)}:${pad2(Math.abs(offMin%60))}`;
      }

      let localMin = wm + (dstActiveDisp ? 60 : 0);
      let dayShift = 0;
      if (localMin >= 1440){ localMin -= 1440; dayShift = +1; }
      if (localMin < 0){ localMin += 1440; dayShift = -1; }
      const hh = Math.floor(localMin/60), mm = Math.round(localMin%60) % 60;

      const badge = dayShift!==0 ? ` <span class="badge">${dayShift>0?'next day':'prev day'}${dstActiveDisp?' · DST':''}</span>` : '';
      document.getElementById('revLocal').innerHTML = `Local: ${fmtHM(hh,mm)}${badge}`;
      document.getElementById('revLine1').textContent =
        `${Y}-${pad2(M)}-${pad2(D)} STS ${fmtHM(hs,ms)} (${tzLabel}) | ${fmtIsoUTC0(new Date(msUTC))} (UTC 0)`;
      document.getElementById('revLine2').textContent =
        `Day/Night: ${dayLen.toFixed(2)} / ${nightLen.toFixed(2)} | minute-of-year: ${moy}`;

      dbgSet({context:'Manual S→C', mode, tzLabel, wm, dstActiveDisp, localMin, msUTC:new Date(msUTC).toISOString(), moy, dayLen, nightLen, hemi, stsMin, dayShift});
    }catch(e){
      err.textContent = e.message || String(e);
      document.getElementById('revLocal').textContent = 'Local: --:--';
      document.getElementById('revLine1').textContent = 'Local date/time | UTC 0';
      document.getElementById('revLine2').textContent = 'Day/Night: — / — | minute-of-year: —';
    }
  }

  // ---------- Wake Lock ----------
  let wakeLock = null;
  async function requestWakeLock(){
    try{
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', ()=>{ document.getElementById('keepAwake').checked = false; });
    }catch(e){
      document.getElementById('autoErr').textContent = (e && e.name==='NotAllowedError')
        ? 'Keep screen on requires a user gesture.'
        : (e?.message || String(e));
      document.getElementById('keepAwake').checked = false;
    }
  }
  function releaseWakeLock(){ if (wakeLock){ wakeLock.release(); wakeLock = null; } }
  document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'visible' && document.getElementById('keepAwake').checked){ requestWakeLock(); } });

  // ---------- Debug (no-op) ----------
  function dbgSet(){ /* intentionally empty */ }

  // ---------- About/Credits loader ----------
  function setupAbout(){
    const btn = document.getElementById('btnAbout');
    const card = document.getElementById('aboutCard');
    const box  = document.getElementById('aboutContent');
    if (!btn || !card || !box) return;

    btn.addEventListener('click', async ()=>{
      const opening = (card.style.display === 'none' || !card.style.display);
      if (opening){
        box.textContent = 'Loading…';
        try{
          let res = await fetch('./about-credits.html', { cache:'no-cache' });
          if (!res.ok) { res = await fetch('./about.html', { cache:'no-cache' }); }
          if (!res.ok) throw new Error('Cannot load about content.');
          const html = await res.text();
          box.innerHTML = html;
        }catch(e){
          box.textContent = e.message || String(e);
        }
        card.style.display = 'block';
        card.scrollIntoView({ behavior:'smooth', block:'start' });
      } else {
        card.style.display = 'none';
      }
    });
  }

  // ---------- Boot ----------
  document.addEventListener('DOMContentLoaded', async () => {
    try{ await loadEqSolDB(); }catch(err){
      document.getElementById('autoErr').textContent = err.message || String(err);
      document.getElementById('manErr').textContent = err.message || String(err);
      document.getElementById('revErr').textContent = err.message || String(err);
    }

    // Live kick & tick
    const kick = ()=>{
      autoUpdate();
      const now = new Date();
      const msToNextMin = (60 - now.getSeconds())*1000 + (1000 - now.getMilliseconds());
      setTimeout(()=>{ autoUpdate(); setInterval(autoUpdate, 60000); }, msToNextMin);
    };
    kick();

    // Quick listeners
    document.getElementById('qMode').addEventListener('change', quickSetModeUI);
    document.getElementById('qBtnRun').addEventListener('click', quickRun);
    quickSetModeUI();

    // Manual listeners & visibility
    const modeA = document.getElementById('zoneModeA');
    const modeB = document.getElementById('zoneModeB');
    const ianaA = document.getElementById('ianaBoxA');
    const offA  = document.getElementById('offsetBoxA');
    const ianaB = document.getElementById('ianaBoxB');
    const offB  = document.getElementById('offsetBoxB');

    function syncA(){
      const isOff = modeA.value==='offset';
      ianaA.style.display = isOff ? 'none' : '';
      offA.style.display  = isOff ? '' : 'none';
      // disable inputs when hidden (for clarity)
      offA.querySelectorAll('input,select').forEach(el => el.disabled = !isOff);
      ianaA.querySelectorAll('input,select').forEach(el => el.disabled = isOff);
    }
    function syncB(){
      const isOff = modeB.value==='offset';
      ianaB.style.display = isOff ? 'none' : '';
      offB.style.display  = isOff ? '' : 'none';
      offB.querySelectorAll('input,select').forEach(el => el.disabled = !isOff);
      ianaB.querySelectorAll('input,select').forEach(el => el.disabled = isOff);
    }
    modeA.addEventListener('change', syncA); syncA();
    modeB.addEventListener('change', syncB); syncB();

    document.getElementById('btnCalcA').addEventListener('click', manualC2S);
    document.getElementById('btnCalcB').addEventListener('click', manualS2C);
    document.getElementById('hemiAuto').addEventListener('change', autoUpdate);

    // About/Credits
    setupAbout();
  });
  </script>
</body>
</html>
